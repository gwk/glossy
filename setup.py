# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

# This is the setup.py for for *ALL* packages; each package symlinks to this file.
# Each package has its own `setup.cfg`.

from distutils.command.build_scripts import build_scripts  # type: ignore
from itertools import chain
from os import chmod, getcwd as current_dir, listdir as list_dir, walk, mkdir as make_dir
from os.path import (abspath as abs_path, basename as path_name, dirname as path_dir, exists as path_exists, isdir as is_dir,
  join as path_join, splitext as split_ext, split as split_dir_name, normpath as norm_path, isfile as is_file)
from pprint import pprint
from sys import stderr
from typing import Any, Iterable, Iterator, List
from configparser import ConfigParser

from setuptools import Command, setup  # type: ignore
from setuptools.config import read_configuration # type: ignore
from setuptools.command.develop import develop  # type: ignore
from setuptools.command.install import install  # type: ignore
from setuptools.command.install_scripts import install_scripts  # type: ignore


# We stubbornly insist on keeping each package directory at the root of the repo.
# Since we want to distribute each package separately, we need a setup.py for each.
# We cannot use a name other than setup.py if we want to support pip, so we have to put each in a different directory.
# We choose to use `{package}/setup.py`.
# This means that `pip3 install -e {package}` does not work, because it gets the egg-link path wrong.
# `pip3 install {package}/` (local install) also does not work,
# because we symlink setup.py into each package and the link breaks when pip copies it into the temp dir.

# Instead, add the repo directory to PYTHONPATH.
# Everything else seems to work correctly.

package_dir = path_dir(norm_path(__file__)) # When run from pip, this is a temp dir, and does not have the name of the package.
bin_src_dir = f'{package_dir}/bin'

base_dir, package_name = split_dir_name(package_dir)
assert package_name
assert not base_dir.endswith('/')
if base_dir: base_dir += '/'
base_prefix_len = len(base_dir)


def msg(*items:Any) -> None: print(' ', *items)


class BuildScripts(build_scripts): # type: ignore
  def run(self) -> None:
    super().run()


class Develop(develop): # type: ignore
  def run(self) -> None:
    super().run()
    install_bins(dst_dir=self.script_dir)


class Install(install): # type: ignore
  def run(self) -> None:
    super().run()


class InstallScripts(install_scripts): # type: ignore
  def run(self) -> None:
    msg('InstallScripts')
    super().run()
    install_bins(dst_dir=self.install_dir)


def install_bins(dst_dir:str) -> None:
  '''
  Generate executable script entry points.
  We do this because standard entry_points/console_scripts have noticeably slow startup times,
  apparently due to overly complex boilerplate.
  '''
  msg('bin_src_dir:', bin_src_dir)
  msg('bin dst_dir:', dst_dir)

  if not is_dir(bin_src_dir):
    msg('note: no bin directory.')
    return
  if not path_exists(dst_dir): make_dir(dst_dir)
  py_path = path_join(dst_dir, 'python3')
  for name in list_dir(bin_src_dir):
    stem, ext = split_ext(name)
    if ext != '.py' or stem.startswith('.') or stem.startswith('_'): continue
    path = path_join(dst_dir, stem.replace('_', '-')) # Omit extension from bin name and use dashes.
    module = f'{package_name}.bin.{stem}'
    msg(f'generating script: {path}')
    with open(path, 'w') as f:
      f.write(bin_template.format(py_path=py_path, module=module))
      chmod(f.fileno(), 0o755)

bin_template = '''\
#!{py_path}
# Generated by pith/setup/setup.py.
from {module} import main
main()
'''


def discover_packages() -> List[str]:
  '''
  Discover subpackages by traversing over the directory tree.
  Verify that all subdirectories have `__init__` files.
  '''
  bad_names = []
  missing_inits = []
  packages = []
  for dir_path, dir_names, file_names in walk(package_dir):
    rel_path = dir_path[base_prefix_len:]
    subpackage_name = rel_path.strip('./').replace('/', '.')
    packages.append(subpackage_name)
    msg('discovered subpackage:', rel_path, '->', subpackage_name)
    # Filter the subdirectories in place, as permitted by `walk`.
    dir_names[:] = filter(is_subpackage, dir_names)
    # Validate names. Collect them so that we can issue all error messages at once, then exit.
    for name in chain(dir_names, file_names):
      if '-' in name: bad_names.append(path_join(dir_path, name))
    if '__init__.py' not in file_names:
      missing_inits.append(path_join(dir_path, '__init__.py'))

  if bad_names: msg(f'bad module names:\n' + '\n'.join(sorted(bad_names)))
  if missing_inits: msg(f'missing package init files:\n' + '\n'.join(sorted(missing_inits)))
  if bad_names or missing_inits: exit(1)
  msg('packages:', *packages)
  return packages


def is_subpackage(dir_name:str) -> bool:
  if '.' in dir_name: return False
  if dir_name in ('__pycache__',): return False
  return True


def main() -> None:

  msg('package_name:', package_name)
  msg('package_dir:', package_dir)
  packages = discover_packages()
  py_module = package_dir + '.py'
  py_modules = [py_module] if path_exists(py_module) else []

  cfg_path = f'{package_dir}/setup.cfg'
  metadata = read_configuration(cfg_path)['metadata'] # Get the metadata the setuptools way, just to be as insane as setuptools.

  if 'name' not in metadata: exit('setup.cfg: error: missing `name`.')

  # Since read_configuration ignores the other sections, load it again.
  cfg_parser = ConfigParser()
  cfg_parser.read(cfg_path)
  cfg = {s:dict(cfg_parser.items(s)) for s in cfg_parser.sections()}

  # Make sure each setup.cfg has the expected build layout sections.
  assert cfg['build'] == { 'build-base' : '_build' }
  assert cfg['bdist'] == { 'dist-dir' : '_build/dist' }
  assert cfg['sdist'] == { 'dist-dir' : '_build/dist' }


  args = dict(
    license='CC0',
    author='George King',
    author_email='george.w.king@gmail.com',
    url='https://github.com/gwk/pithy',

    packages=packages,
    cmdclass={
      'build_scripts': BuildScripts,
      'develop': Develop,
      'install': Install,
      'install_scripts': InstallScripts,
    },
    py_modules=[],
    package_dir={package_name:package_dir},
    **metadata,
  )


  # Note that we use an absolute path for package_dir, which is unconventional.
  # We do this to avoid ambiguity when CWD is different from setup.py (which in our case is requried; see above).
  # `package_dir={'':'../..'}` results in a "Can't get a consistent path to setup script from installation directory".
  # https://stackoverflow.com/questions/9401916/cant-get-a-consistent-path-to-setup-script-from-installation-directory
  # suggests that adding a pyproject.toml file might fix it. However this causes reams of 'bad module' errors,
  # apparently because it causes pip to look into the entire .git directory.

  #pprint(args)
  setup(**args)


if __name__ == '__main__': main()
