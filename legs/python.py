# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

import re
from argparse import Namespace
from collections import defaultdict
from pprint import pformat
from typing import Dict, Tuple

from pithy.fs import add_file_execute_permissions
from pithy.io import *
from pithy.string import render_template

from .defs import Mode, ModeTransitions
from .dfa import DFA


def output_python3(path:str, mode_transitions:Dict[int, Dict[str, Tuple[int, str]]], dfa:DFA,
  pattern_descs:Dict[str, str], license:str, args:Namespace):

  match_node_kinds = { match_node : dfa.match_name(match_node) for match_node in dfa.match_nodes}

  kinds = { name : py_safe_sym(name) for name in dfa.pattern_names }
  kinds['incomplete'] = 'incomplete'
  assert len(kinds) == len(set(kinds.values()))

  with open(path, 'w', encoding='utf8') as f:
    src = render_template(template,
      license=license,
      match_node_kinds=fmt_obj(match_node_kinds),
      pattern_descs=fmt_obj(pattern_descs),
      patterns_path=args.path,
      transitions=fmt_obj(dfa.transitions),
      mode_transitions=fmt_obj(dict(mode_transitions)),
      Name=args.type_prefix,
    )
    f.write(src)
    if args.test:
      test_src = render_template(test_template, Name=args.type_prefix)
      f.write(test_src)


def fmt_obj(object:Any) -> str:
  return pformat(object, indent=2, width=128, compact=True)


template = r'''# ${license}
# This file was generated by legs from ${patterns_path}.

from legs_base import Lexer
from typing import Dict, Iterator, Tuple


class ${Name}Lexer(Lexer):

  transitions:Dict[int, Dict[int, int]] = ${transitions}

  match_node_kinds:Dict[int, str] = ${match_node_kinds}

  pattern_descs:Dict[str, str] = ${pattern_descs}

  mode_transitions:Dict[str, Dict[str, Tuple[str, str]]] = ${mode_transitions}
'''


test_template = '''
from legs_base import test_main

if __name__ == '__main__': test_main(${Name}Lexer)
'''


def py_safe_sym(name:str) -> str:
  name = re.sub(r'[^\w]', '_', name)
  if name[0].isdigit():
    name = '_' + name
  if name in py_reserved_syms:
    name += '_'
  return name


py_reserved_syms = {
  'False',
  'class',
  'finally',
  'is',
  'return',
  'None',
  'continue',
  'for',
  'lambda',
  'try',
  'True',
  'def',
  'from',
  'nonlocal',
  'while',
  'and',
  'del',
  'global',
  'not',
  'with',
  'as',
  'elif',
  'if',
  'or',
  'yield',
  'assert',
  'else',
  'import',
  'pass',
  'break',
  'except',
  'in',
  'raise',
}
