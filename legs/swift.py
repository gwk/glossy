# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

import re

from collections import defaultdict
from pithy.fs import add_file_execute_permissions
from pithy.strings import render_template


def output_swift(dfa, rules_path, path, test, type_prefix, license):
  preMatchNodes = dfa.preMatchNodes
  rule_name_kinds = { name : swift_safe_sym(name) for name in dfa.ruleNames }
  token_kind_case_defs = ['case {}'.format(kind) for kind in sorted(rule_name_kinds.values())]

  def rule_desc(name):
    try:
      literal = dfa.literalRules[name]
      if all((c.isprintable() and not c.isspace()) for c in literal):
        return '"`{}`"'.format(literal)
    except KeyError: pass
    return swift_repr(name)

  token_kind_case_descs = ['case .{}: return {}'.format(kind, rule_desc(name)) for name, kind in rule_name_kinds.items()]

  dfa_nodes = sorted(dfa.transitions.keys())

  def byte_case_ranges(chars):
    ranges = []
    for char in chars:
      if not ranges:
        ranges.append((char, char))
      else:
        low, prev = ranges[-1]
        if prev + 1 == char:
          ranges[-1] = (low, char)
        else:
          ranges.append((char, char))
    def fmt(l, h):
      if l == h: return hex(l)
      return hex(l) + (', ' if l + 1 == h else '...') + hex(h)
    return [fmt(*r) for r in ranges]

  def byte_case(chars, dst, returns):
    return 'case {chars}: state = {dst}{suffix}'.format(
      chars=', '.join(byte_case_ranges(chars)),
      dst=dst,
      suffix='; return nil' if returns else '')

  def byte_cases(node, returns):
    dst_chars = defaultdict(list)
    for char, dst in sorted(dfa.transitions[node].items()):
      dst_chars[dst].append(char)
    dst_chars_sorted = sorted(dst_chars.items(), key=lambda p: p[1])
    return [byte_case(chars, dst, returns) for dst, chars in dst_chars_sorted]

  def transition_code(node):
    # TODO: condense cases into ranges and tuple patterns.
    d = dfa.transitions[node]
    is_pre_match = node in preMatchNodes
    if not d: # no transitions; omit the switch and unconditionally take the default action.
      if is_pre_match:
        return '\n      state = 1; return nil'
      else:
        return '\n      break'
    # has transitions; need an inner switch.
    return render_template('''
      switch byte {
      ${byte_cases}
      default: ${default_action}
      }''',
      byte_cases='\n      '.join(byte_cases(node, returns=True)),
      default_action='state = 1; return nil' if is_pre_match else 'break top')

  def state_case(node):
    name = dfa.matchNodeNames.get(node)
    update_pos_code = ''
    update_kind_code = ''
    if name:
      update_pos_code = '\n      tokenEnd = pos'
      if node == 1:
        update_kind_code = '; assert(tokenKind == .invalid)'
      else:
        kind = rule_name_kinds[name]
        update_kind_code = '; tokenKind = .{}'.format(kind)
    else:
      match_code = ''
    return 'case {node}:{update_pos_code}{update_kind_code}{transition_code}'.format(
      node=node,
      update_pos_code=update_pos_code,
      update_kind_code=update_kind_code,
      transition_code=transition_code(node))

  state_cases = [state_case(node) for node in dfa_nodes[1:]]

  def finish_case(node):
    return 'case {node}: tokenEnd = pos; tokenKind = .{kind}'.format(
      node=node, kind=rule_name_kinds[dfa.matchNodeNames[node]])

  finish_cases = [finish_case(node) for node in dfa.matchNodes]

  with open(path, 'w', encoding='utf8') as f:
    if test:
      f.write('#!/usr/bin/env swift\n')
    src = render_template(template,
      finish_cases='\n      '.join(finish_cases),
      license=license,
      Name=type_prefix,
      path=path,
      rules_path=rules_path,
      restart_byte_cases='\n    '.join(byte_cases(0, returns=False)),
      start_byte_cases='\n      '.join(byte_cases(0, returns=True)),
      state_cases='\n    '.join(state_cases),
      token_kind_case_defs='\n  '.join(token_kind_case_defs),
      token_kind_case_descs='\n    '.join(token_kind_case_descs),
    )
    f.write(src)
    if test:
      test_src = render_template(test_template, Name=type_prefix)
      f.write(test_src)
      add_file_execute_permissions(f.fileno())


template = r'''// ${license}.
// This file was generated by legs from ${path}.

import Foundation


public enum ${Name}TokenKind: CustomStringConvertible {
  ${token_kind_case_defs}

  public var description: String {
    switch self {
    ${token_kind_case_descs}
    }
  }
}


public struct ${Name}Token: CustomStringConvertible {
  public let pos: Int
  public let end: Int
  public let kind: ${Name}TokenKind

  public var description: String {
    return "\(kind):\(pos)-\(end)"
  }
}


public class ${Name}Source: CustomStringConvertible {

  public let name: String
  public let data: Data
  public fileprivate(set) var newlinePositions: [Int] = []

  public init(name: String, data: Data) {
    self.name = name
    self.data = data
  }

  public var description: String {
    return "${Name}Source(name: \(name), data: \(data))"
  }

  public func lex() -> ${Name}Lexer {
    return ${Name}Lexer(source: self)
  }

  public var tokens: [${Name}Token] {
    return Array(lex())
  }

  public func lineIndex(pos: Int) -> Int {
    // TODO: use binary search.
    for (index, newlinePos) in newlinePositions.enumerated() {
      if pos <= newlinePos { // newlines are considered to be the last character of a line.
        return index
      }
    }
    return newlinePositions.count
  }

  public func lineRange(pos: Int) -> CountableRange<Int> {
   // returns the range in `data` for the line containing `pos`,
   // including the terminating newline character if it is present.
    var start = pos
    while start > 0 {
      let i = start - 1
      if data[i] == 0x0a { break }
      start = i
    }
    var end = pos
    while end < data.count {
      let i = end
      end += 1
      if data[i] == 0x0a { break }
    }
    return start..<end
  }

  public func getColumn(line: String, lineStart: Int, pos: Int) -> Int {
    let utf8 = line.utf8
    let utf8Index = utf8.index(utf8.startIndex, offsetBy: pos - lineStart)
    if let charIndex = String.Index(utf8Index, within: line) {
        return line.distance(from: line.startIndex, to: charIndex)
    } else {
      return -1
    }
  }

  public func getLineAndColumn(range: CountableRange<Int>, pos: Int) -> (Bool, String, Int) {
    if let line = String(bytes: data[range], encoding: .utf8) {
      return (true, line, getColumn(line: line, lineStart: range.startIndex, pos: pos))
    } else {
      // TODO: this should return a best-effort representation if unicode decoding fails.
      return (false, "?", -1)
    }
  }

  public func underline(col: Int, endCol: Int = -1) -> String {
    if col < 0 { return "" }
    let indent = String(repeating: " ", count: col)
    if col < endCol {
      return indent + String(repeating: "~", count: endCol - col)
    } else {
      return indent + "^"
    }
  }

  public func underlines(col: Int, lineLength: Int, endCol: Int) -> (String, String) {
    // for two distinct lines, return start and end underlines.
    let startLine, endLine: String
    if col < 0 {
      startLine = ""
    } else {
      let spaces = String(repeating: " ", count: col)
      let squigs = String(repeating: "~", count: lineLength - col)
      startLine = spaces + squigs
    }
    if endCol < 0 {
      endLine = ""
    } else {
      endLine = String(repeating: "~", count: endCol)
    }
    return (startLine, endLine)
  }

  private func colString(_ col: Int) -> String {
    return (col >= 0) ? String(col + 1) : "?"
  }

  public func diagnostic(token: ${Name}Token, prefix: String, msg: String = "", showMissingFinalNewline: Bool = true)
   -> String {
    return diagnostic(pos: token.pos, end: token.end, prefix: prefix, msg: msg, showMissingFinalNewline: showMissingFinalNewline)
  }

  public func diagnostic(pos: Int, end: Int? = nil, prefix: String, msg: String = "", showMissingFinalNewline: Bool = true)
   -> String {

    func diagLine(_ line: String, _ returnSymbol: Bool) -> String {
      if line.hasSuffix("\n") {
        if returnSymbol {
          var s = line
          s.remove(at: s.index(before: s.endIndex))
          return s + "\u{23CE}\n"
        } else {
          return line
        }
      } else if showMissingFinalNewline {
        return line + "\u{23CE}\u{0353}\n"
      } else {
        return line + "\n"
      }
    }

    let msgSpace = (msg.isEmpty || msg.hasPrefix("\n")) ? "" : " "
    let lineNum = lineIndex(pos: pos) + 1
    let range = lineRange(pos: pos)
    let (_, line, col) = getLineAndColumn(range: range, pos: pos)
    let common = "\(prefix): \(name):\(lineNum):\(colString(col))"
    if let end = end {
      if end <= range.endIndex { // single line.
        if pos < end { // multiple columns.
          let endCol = getColumn(line: line, lineStart: range.startIndex, pos: end)
          let under = underline(col: col, endCol: endCol)
          let retSym = (end == range.endIndex)
          return "\(common)-\(colString(endCol)):\(msgSpace)\(msg)\n  \(diagLine(line, retSym))  \(under)\n"
        } // else: single line, single column case below.
      } else { // multiline.
        let endLineNum = lineIndex(pos: end) + 1
        let endLineRange = lineRange(pos: end)
        let (_, endLine, endCol) = getLineAndColumn(range: endLineRange, pos: end)
        let endRetSym = (end == endLineRange.endIndex)
        let (under, endUnder) = underlines(col: col, lineLength: line.characters.count, endCol: endCol)
        let a = "\(common)--\(endLineNum):\(colString(endCol)):\(msgSpace)\(msg)\n"
        let b = "  \(diagLine(line, true))  \(under)…\n"
        let c = "  \(diagLine(endLine, endRetSym)) …\(endUnder)\n"
        return "\(a)\(b)\(c)"
      }
    }
    // single line, single column.
    let retSym = (pos == range.endIndex - 1)
    return "\(common):\(msgSpace)\(msg)\n  \(diagLine(line, retSym))  \(underline(col: col))\n"
  }
}


public struct ${Name}Lexer: Sequence, IteratorProtocol {

  public typealias Element = ${Name}Token
  public typealias Iterator = ${Name}Lexer

  public private(set) var source: ${Name}Source

  private var isFinished = false
  private var state: UInt = 0
  private var pos: Int = 0
  private var tokenPos: Int = 0
  private var tokenEnd: Int = 0
  private var tokenKind: ${Name}TokenKind = .invalid

  public init(source: ${Name}Source) {
    self.source = source
  }

  public mutating func next() -> ${Name}Token? {
    while pos < source.data.count {
      let byte = source.data[pos]
      if byte == 0x0a {
        source.newlinePositions.append(pos)
      }
      let token = step(byte: source.data[pos])
      pos += 1
      if token != nil {
        return token
      }
    }
    if tokenPos < pos {
      // update tokenEnd to pos for all match states.
      switch state {
      ${finish_cases}
      default: break
      }
      // flush any pending token, possibly backtracking.
      state = 0 // reset state in case we backtrack.
      return flushToken()
    }
    return nil
  }

  @inline(__always)
  private mutating func step(byte: UInt8) -> ${Name}Token? {
    top: switch state {

    ${state_cases}

    case 0: // start state.
      switch byte {
      ${start_byte_cases}
      default: assert(tokenKind == .invalid); return nil
      }
    default: fatalError("lexer is in impossible state: \(state)")
    }

    // restart.
    let token = flushToken()
    switch byte {
    ${restart_byte_cases}
    default: state = 1 // transition to invalid.
    }
    return token
  }

  @inline(__always)
  private mutating func flushToken() -> ${Name}Token {
    let tPos = self.tokenPos
    let end = self.tokenEnd > 0 ? self.tokenEnd : self.pos
    let kind = self.tokenKind
    assert(tPos < end, "empty token; pos: \(tPos); kind: \(kind)")
    self.tokenKind = .invalid
    self.tokenPos = end
    self.tokenEnd = 0
    self.pos = end // backtrack to last match position. can take quadratic time for pathological rule sets.
    return ${Name}Token(pos: tPos, end: end, kind: kind)
  }
}
'''

test_template = r'''
// test main.

import Foundation

func repr(_ string: String) -> String {
  var r = "\""
  for char in string.unicodeScalars {
    switch char {
    case UnicodeScalar(0x20)...UnicodeScalar(0x7E): r.append(String(char))
    case "\0": r.append("\\0")
    case "\\": r.append("\\\\")
    case "\t": r.append("\\t")
    case "\n": r.append("\\n")
    case "\r": r.append("\\r")
    case "\"": r.append("\\\"")
    default: r.append("\\{\(String(char.value, radix: 16, uppercase: false))}")
    }
  }
  r.append("\"")
  return r
}

func test(index: Int, arg: String) {
  let name = "arg\(index)"
  print("\n\(name): \(repr(arg))")
  let data = Data(arg.utf8)
  let source = ${Name}Source(name: name, data: data)
  for token in source.lex() {
    let d = source.diagnostic(token: token, prefix: "token", msg: token.kind.description,
      showMissingFinalNewline: false)
    print(d, terminator: "")
  }
}

for (i, arg) in CommandLine.arguments.enumerated() {
  if i == 0 { continue }
  test(index: i, arg: arg)
}
'''


swift_escapes = {
  '\0' : '\\0',
  '\\' : '\\\\',
  '\t' : '\\t',
  '\n' : '\\n',
  '\r' : '\\r',
  '"'  : '\\"',
}

def swift_escape_literal_char(c):
  try:
    return swift_escapes[c]
  except KeyError: pass
  if c.isprintable():
    return c
  return '\\u{{{:x}}}'.format(ord(c))

def swift_repr(string):
  return '"{}"'.format(''.join(swift_escape_literal_char(c) for c in string))


swift_reserved_syms = {
  '#column',
  '#file',
  '#function',
  '#line',
  'Self',
  '_',
  'as',
  'associatedtype',
  'break',
  'case',
  'catch',
  'class',
  'continue',
  'default',
  'defer',
  'deinit',
  'do',
  'dynamicType',
  'else',
  'enum',
  'extension',
  'fallthrough',
  'false',
  'false',
  'for',
  'func',
  'guard',
  'if',
  'import',
  'in',
  'in',
  'init',
  'inout',
  'internal',
  'is',
  'let',
  'nil',
  'operator',
  'private',
  'protocol',
  'public',
  'repeat',
  'rethrows',
  'return',
  'self',
  'static',
  'struct',
  'subscript',
  'super',
  'switch',
  'throw',
  'throws',
  'true',
  'try',
  'typealias',
  'var',
  'where',
  'while',
}

def swift_safe_sym(name):
  return name + ('_' if name in swift_reserved_syms else '')
