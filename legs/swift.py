# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

import re

from argparse import Namespace
from importlib.util import find_spec as find_module_spec
from itertools import chain
from typing import Any, DefaultDict, Dict, List, Tuple, cast
from pithy.fs import add_file_execute_permissions, path_dir, path_join
from pithy.string import render_template
from pithy.iterable import closed_int_intervals

from .defs import Mode, ModeTransitions
from .dfa import DFA


def output_swift(path:str, mode_transitions:Dict[int, Dict[str, Tuple[int, str]]], dfa:DFA,
 node_modes:Dict[int, Mode], pattern_descs:Dict[str, str], license:str, args:Namespace) -> None:

  kinds = { name : swift_safe_sym(name) for name in dfa.pattern_names }
  kinds['incomplete'] = 'incomplete'
  assert len(kinds) == len(set(kinds.values()))
  token_kind_case_defs = ['case {}'.format(kind) for kind in sorted(kinds.values())]

  # Token kind descriptions.
  def pattern_desc(name:str) -> str: return swift_repr(pattern_descs[name])
  token_kind_case_descs = ['case .{}: return {}'.format(kind, pattern_desc(name)) for name, kind in sorted(kinds.items())]

  # Mode transitions dictionary.

  def swift_mode_transition(d:Dict[str, Tuple[int, str]]) -> Dict[SwiftEnum, Tuple[int, SwiftEnum]]:
    return {SwiftEnum(parent_kind): (child_start, SwiftEnum(child_kind)) for parent_kind, (child_start, child_kind) in d.items()}

  if mode_transitions:
    mode_transition_items = '\n'.join(f'    {parent_start}: {swift_repr(swift_mode_transition(d))},' for parent_start, d in mode_transitions.items())
  else:
    mode_transition_items = ':'

  # State cases.

  def byte_case_patterns(chars:List[int]) -> List[str]:
    def fmt(l:int, h:int) -> str:
      if l == h: return hex(l)
      return hex(l) + (', ' if l + 1 == h else '...') + hex(h)
    return [fmt(*r) for r in closed_int_intervals(chars)]

  def byte_case(chars, dst:int) -> str:
    pattern_name = dfa.match_name(dst)
    kind = None if pattern_name is None else kinds.get(pattern_name)
    return 'case {chars}: state = {dst}{suffix}'.format(
      chars=', '.join(byte_case_patterns(chars)),
      dst=dst,
      suffix=f'; end = pos+1; kind = .{kind}' if kind else '')

  def byte_cases(node:int) -> List[str]:
    dst_chars:DefaultDict[int, List[int]] = DefaultDict(list)
    for char, dst in sorted(dfa.transitions[node].items()):
      dst_chars[dst].append(char)
    dst_chars_sorted = sorted(dst_chars.items(), key=lambda p: p[1])
    return [byte_case(chars, dst) for dst, chars in dst_chars_sorted]

  def transition_code(node:int) -> str:
    d = dfa.transitions[node]
    if not d: return 'break loop' # no transitions.
    return render_template('''switch byte {
        ${byte_cases}
        default: break loop
        }''',
      byte_cases='\n        '.join(byte_cases(node)))

  def state_case(node:int) -> str:
    mode = node_modes[node]
    name = dfa.match_name(node)
    if name:
      desc = name
    elif node in dfa.pre_match_nodes:
      desc = mode.name + ' pre-match'
    else:
      desc = mode.name + ' post-match'
    return 'case {node}: // {desc}.\n        {transition_code}'.format(
      desc=desc,
      node=node,
      transition_code=transition_code(node))

  dfa_nodes = sorted(dfa.transitions.keys())
  state_cases = [state_case(node) for node in dfa_nodes]

  with open(path, 'w', encoding='utf8') as f:
    src = render_template(template,
      license=license,
      mode_transition_items=mode_transition_items,
      Name=args.type_prefix,
      patterns_path=args.path,
      state_cases='\n      '.join(state_cases),
      token_kind_case_defs='\n  '.join(token_kind_case_defs),
      token_kind_case_descs='\n    '.join(token_kind_case_descs),
    )
    f.write(src)
    if args.test:
      # Append the base source because `swift` will only interpret a single file.
      spec = find_module_spec('legs')
      assert spec is not None
      pkg_dir_path = path_dir(cast(str, spec.origin))
      legs_base_path = path_join(pkg_dir_path, 'legs_base.swift')
      legs_base_contents = open(legs_base_path).read()
      f.write(legs_base_contents)
      # Write the test main function.
      test_src = render_template(test_template, Name=args.type_prefix)
      f.write(test_src)


template = r'''// ${license}
// This file was generated by legs from ${patterns_path}.

import Foundation


public enum ${Name}TokenKind: CustomStringConvertible {
  ${token_kind_case_defs}

  public var description: String {
    switch self {
    ${token_kind_case_descs}
    }
  }
}


public struct ${Name}Lexer: Sequence, IteratorProtocol {

  public typealias Element = Token<${Name}TokenKind>
  public typealias Iterator = ${Name}Lexer

  public let source: Source

  private var stack: [(UInt, ${Name}TokenKind?)] = [(0, nil)]
  private var pos: Int = 0

  public init(source: Source) {
    self.source = source
  }

  public mutating func next() -> Token<${Name}TokenKind>? {
    let (modeStart, popKind) = self.stack.last!
    let linePos = (source.newlinePositions.last ?? -1) + 1
    let lineIdx = source.newlinePositions.count
    var pos = self.pos
    var state = modeStart
    var end: Int? = nil
    var kind: ${Name}TokenKind = .incomplete

    loop: while pos < source.text.count {
      let byte = source.text[pos]

      switch state {

      ${state_cases}

      default: fatalError("${Name}Lexer.next: impossible state: \(state)")
      }
      if byte == 0x0a {
        source.newlinePositions.append(pos)
      }
      pos += 1
    }

    // matching stopped or reached end of text.
    if pos == self.pos { // no more tokens; done.
      assert(pos == source.text.count)
      return nil
    }

    let tokenPos = self.pos
    let tokenEnd = end ?? pos
    assert(tokenPos < tokenEnd, "tokenPos: \(tokenPos); tokenEnd: \(tokenEnd)")
    if end == nil { assert(kind == .incomplete) }
    self.pos = tokenEnd
    if kind == popKind {
      stack.removeLast()
    } else {
      if let childPair = ${Name}Lexer.modeTransitions[modeStart]?[kind] {
        stack.append(childPair)
      }
    }
    return Token(pos: tokenPos, end: tokenEnd, linePos: linePos, lineIdx: lineIdx, kind: kind)
  }

  private static let modeTransitions: Dictionary<UInt, Dictionary<${Name}TokenKind, (UInt, ${Name}TokenKind?)>> = [
${mode_transition_items}
  ]
}
'''

test_template = r'''

// Legs test main.

func test(index: Int, arg: String) {
  let name = "arg\(index)"
  print("\n\(name): \(ployRepr(arg))")
  let text = Array(arg.utf8)
  let source = Source(name: name, text: text)
  for token in Lexer(source: source) {
    var from = 2 // "0_" prefix is the common case.
    let base: Int?
    switch token.kind.description {
    case "num":   base = 10; from = 0
    case "bin":   base = 2
    case "quat":  base = 4
    case "oct":   base = 8
    case "dec":   base = 10
    case "hex":   base = 16
    default:      base = nil
    }
    var msg: String = "error"
    if let base = base {
      do {
        let val = try source.parseDigits(token: token, from: from, base: base)
        msg = "\(token.kind): \(val)"
      } catch let e {
        msg = "error: \(e)"
      }
    } else {
      msg = token.kind.description
    }
    print(source.diagnostic(token: token, msg: msg, showMissingNewline: false), terminator: "")
  }
}

for (i, arg) in CommandLine.arguments.enumerated() {
  if i == 0 { continue }
  test(index: i, arg: arg)
}
'''


class SwiftEnum:
  def __init__(self, string:str) -> None:
    self.string = string

  @property
  def swift_repr(self) -> str: return '.' + self.string


swift_escapes:Dict[str, str] = {
  '\0' : '\\0',
  '\\' : '\\\\',
  '\t' : '\\t',
  '\n' : '\\n',
  '\r' : '\\r',
  '"'  : '\\"',
}

def swift_escape_literal_char(c:str) -> str:
  try:
    return swift_escapes[c]
  except KeyError: pass
  if c.isprintable():
    return c
  return '\\u{{{:x}}}'.format(ord(c))

def swift_esc_str(string:str) -> str:
  return ''.join(swift_escape_literal_char(c) for c in string)

def swift_repr(obj:Any) -> str:
  if isinstance(obj, int): return repr(obj)
  if isinstance(obj, str): return '"{}"'.format(swift_esc_str(obj))
  if isinstance(obj, SwiftEnum): return obj.swift_repr
  if isinstance(obj, tuple): return f'({",".join(swift_repr(el) for el in obj)})'
  if isinstance(obj, dict): return f'[{",".join(swift_repr_kv(kv) for kv in obj.items())}]'
  raise ValueError(obj)

def swift_repr_kv(kv:Tuple[Any, Any]) -> str: return f'{swift_repr(kv[0])}:{swift_repr(kv[1])}'


def swift_safe_sym(name:str) -> str:
  name = re.sub(r'[^\w]', '_', name)
  if name[0].isdigit():
    name = '_' + name
  if name in swift_reserved_syms:
    name += '_'
  return name

swift_reserved_syms = {
  # declarations.
  'associatedtype',
  'class',
  'deinit',
  'enum',
  'extension',
  'fileprivate',
  'func',
  'import',
  'init',
  'inout',
  'internal',
  'let',
  'open',
  'operator',
  'private',
  'protocol',
  'public',
  'static',
  'struct',
  'subscript',
  'typealias',
  'var',
  # statements.
  'case',
  'continue',
  'default',
  'defer',
  'do',
  'else',
  'fallthrough',
  'for',
  'guard',
  'if',
  'in',
  'repeat',
  'return',
  'switch',
  'where',
  'while',
  # expressions and types.
  'as',
  'Any',
  'catch',
  'false',
  'is',
  'nil',
  'rethrows',
  'super',
  'self',
  'Self',
  'throw',
  'throws',
  'true',
  'try',
  # patterns.
  '_',
}
