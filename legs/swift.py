# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

import re

from collections import defaultdict
from pithy.fs import add_file_execute_permissions
from pithy.strings import render_template


def output_swift(dfa, rules_path, path, test, license, name):
  preMatchNodes = dfa.preMatchNodes

  token_kinds = [name for node, name in sorted(dfa.matchNodeNames.items())]
  token_kind_case_defs = ['case {}'.format(kind) for kind in token_kinds]
  token_kind_case_descriptions = ['case .{}: return {}'.format(name, swift_repr(name)) for name in token_kinds]
  dfa_nodes = sorted(dfa.transitions.keys())

  def byte_case_ranges(chars):
    ranges = []
    for char in chars:
      if not ranges:
        ranges.append((char, char))
      else:
        low, prev = ranges[-1]
        if prev + 1 == char:
          ranges[-1] = (low, char)
        else:
          ranges.append((char, char))
    def fmt(l, h):
      if l == h: return hex(l)
      return hex(l) + (', ' if l + 1 == h else '...') + hex(h)
    return [fmt(*r) for r in ranges]

  def byte_case(chars, dst, returns):
    return 'case {chars}: state = {dst}{suffix}'.format(
      chars=', '.join(byte_case_ranges(chars)),
      dst=dst,
      suffix='; return nil' if returns else '')

  def byte_cases(node, returns):
    dst_chars = defaultdict(list)
    for char, dst in sorted(dfa.transitions[node].items()):
      dst_chars[dst].append(char)
    dst_chars_sorted = sorted(dst_chars.items(), key=lambda p: p[1])
    return [byte_case(chars, dst, returns) for dst, chars in dst_chars_sorted]

  def transition_code(node):
    # TODO: condense cases into ranges and tuple patterns.
    d = dfa.transitions[node]
    is_pre_match = node in preMatchNodes
    if not d: # no transitions; omit the switch and unconditionally take the default action.
      if is_pre_match:
        return '\n      state = 1; return nil'
      else:
        return '\n      break'
    # has transitions; need an inner switch.
    return render_template('''
      switch byte {
      ${byte_cases}
      default: ${default_action}
      }''',
      byte_cases='\n      '.join(byte_cases(node, returns=True)),
      default_action='state = 1; return nil' if is_pre_match else 'break top')

  def state_case(node):
    kind = dfa.matchNodeNames.get(node)
    update_pos_code = ''
    update_kind_code = ''
    if kind:
      update_pos_code = '\n      tokenEnd = pos'
      if node == 1:
        update_kind_code = '; assert(tokenKind == .invalid)'
      else:
        update_kind_code = '; tokenKind = .{}'.format(kind)
    else:
      match_code = ''
    return 'case {node}:{update_pos_code}{update_kind_code}{transition_code}'.format(
      node=node,
      update_pos_code=update_pos_code,
      update_kind_code=update_kind_code,
      transition_code=transition_code(node))

  state_cases = [state_case(node) for node in dfa_nodes[1:]]
  Name = name.capitalize()

  def finish_case(node):
    return 'case {node}: tokenEnd = pos; tokenKind = .{kind}'.format(
      node=node, kind=dfa.matchNodeNames[node])

  finish_cases = [finish_case(node) for node in dfa.matchNodes]

  with open(path, 'w') as f:
    if test:
      f.write('#!/usr/bin/env swift\n')
    src = render_template(template,
      finish_cases='\n      '.join(finish_cases),
      license=license,
      Name=Name,
      path=path,
      rules_path=rules_path,
      restart_byte_cases='\n    '.join(byte_cases(0, returns=False)),
      start_byte_cases='\n      '.join(byte_cases(0, returns=True)),
      state_cases='\n\n    '.join(state_cases),
      token_kind_case_defs='\n  '.join(token_kind_case_defs),
      token_kind_case_descriptions='\n    '.join(token_kind_case_descriptions),
    )
    f.write(src)
    if test:
      test_src = render_template(test_template, Name=Name)
      f.write(test_src)
      add_file_execute_permissions(f.fileno())


template = r'''// ${license}.
// This file was generated by legs from ${path}.

import Foundation


public enum ${Name}TokenKind: CustomStringConvertible {
  ${token_kind_case_defs}

  public var description: String {
    switch self {
    ${token_kind_case_descriptions}
    }
  }
}


public struct ${Name}Token: CustomStringConvertible {
  let pos: Int
  let end: Int
  let kind: ${Name}TokenKind

  public var description: String {
    return "\(kind):\(pos)-\(end)"
  }
}


public struct ${Name}Source {

  public let name: String
  public let data: Data
  public var lineIndexes: [Int]

  public init(name: String, data: Data, lineIndexes: [Int] = []) {
    self.name = name
    self.data = data
    self.lineIndexes = lineIndexes
  }
}


public struct ${Name}SourceLoc {
  public var pos: Int
  public var line: Int
  public var column: Int
}


public struct ${Name}Lexer: Sequence, IteratorProtocol {

  public typealias TokenKind = ${Name}TokenKind
  public typealias Token = ${Name}Token
  public typealias Source = ${Name}Source
  public typealias SourceLoc = ${Name}SourceLoc

  public typealias Element = Token
  public typealias Iterator = ${Name}Lexer
  public typealias Byte = UInt8

  public let source: Source

  private var isFinished = false
  private var state: UInt = 0
  private var pos: Int = 0
  private var tokenPos: Int = 0
  private var tokenEnd: Int = 0
  private var tokenKind: TokenKind = .invalid

  public init(name: String, data: Data) {
    self.source = Source(name: name, data: data)
  }

  public mutating func next() -> Token? {
    while pos < source.data.count {
      let token = step(byte: source.data[pos])
      pos += 1
      if token != nil {
        return token
      }
    }
    if tokenPos < pos {
      // update tokenEnd to pos for all match states.
      switch state {
      ${finish_cases}
      default: break
      }
      // flush any pending token, possibly backtracking.
      state = 0 // reset state in case we backtrack.
      return flushToken()
    }
    return nil
  }

  @inline(__always)
  public mutating func step(byte: Byte) -> Token? {
    top: switch state {

    ${state_cases}

    case 0: // start state.
      switch byte {
      ${start_byte_cases}
      default: assert(tokenKind == .invalid); return nil
      }
    default: fatalError("lexer is in impossible state: \(state)")
    }

    // restart.
    let token = flushToken()
    switch byte {
    ${restart_byte_cases}
    default: state = 1 // transition to invalid.
    }
    return token
  }

  @inline(__always)
  private mutating func flushToken() -> Token {
    let tPos = self.tokenPos
    let end = self.tokenEnd > 0 ? self.tokenEnd : self.pos
    let kind = self.tokenKind
    assert(tPos < end, "empty token; pos: \(tPos); kind: \(kind)")
    self.tokenKind = .invalid
    self.tokenPos = end
    self.tokenEnd = 0
    self.pos = end // backtrack to last match position. can take quadratic time for pathological rule sets.
    return Token(pos: tPos, end: end, kind: kind)
  }
}
'''

test_template = r'''
// test main.

import Foundation

func repr(_ string: String) -> String {
  var r = "\""
  for char in string.unicodeScalars {
    switch char {
    case UnicodeScalar(0x20)...UnicodeScalar(0x7E): r.append(String(char))
    case "\0": r.append("\\0")
    case "\\": r.append("\\\\")
    case "\t": r.append("\\t")
    case "\n": r.append("\\n")
    case "\r": r.append("\\r")
    case "\"": r.append("\\\"")
    default: r.append("\\{\(String(char.value, radix: 16, uppercase: false))}")
    }
  }
  r.append("\"")
  return r
}

func test(index: Int, arg: String) {
  print("\n", repr(arg), separator: "", terminator: ":\n")
  let data = Data(arg.utf8)
  let lexer = ${Name}Lexer(name: String(index), data: data)
  for token in lexer {
    print(token, separator: "")
  }
}

for (i, arg) in CommandLine.arguments.enumerated() {
  if i == 0 { continue }
  test(index: i, arg: arg)
}
'''


swift_escapes = {
  '\0' : '\\0',
  '\\' : '\\\\',
  '\t' : '\\t',
  '\n' : '\\n',
  '\r' : '\\r',
  '"'  : '\\"',
}

def swift_escape_literal_char(c):
  try:
    return swift_escapes[c]
  except KeyError: pass
  if c.isprintable():
    return c
  return '\\u{{{:x}}}'.format(ord(c))

def swift_repr(string):
  return '"{}"'.format(''.join(swift_escape_literal_char(c) for c in string))

